<script>
// === STEP 1: HK20 計算層（不改 UI）===

// 取得 5 位數股票欄位（例：00700）
function getStockCols(rows){
  const keys = Object.keys(rows[0] || {});
  return keys.filter(k => /^\d{5}$/.test(k));
}

// 安全轉數字
const toNum = v => {
  const x = Number(v);
  return Number.isFinite(x) ? x : NaN;
};

// 取陣列最後 n 個元素
const lastN = (arr, n) => arr.slice(Math.max(0, arr.length - n));

// 中位數 / MAD
function median(xs){
  const a = xs.slice().sort((x,y)=>x-y);
  const m = (a.length-1)/2;
  return (a.length % 2) ? a[m|0] : 0.5*(a[m|0] + a[(m|0)+1]);
}
function mad(xs){
  const med = median(xs);
  const dev = xs.map(v => Math.abs(v - med));
  return median(dev);
}
// robust z（Iglewicz & Hoaglin 的 modified z-score：0.6745*(x - median)/MAD）
function robustZAll(values){
  const med = median(values);
  const M = mad(values);
  return {
    med,
    mad: M,
    rz: values.map(v => (M ? 0.6745*(v - med)/M : 0))
  };
}

// 百分位名次（Statistics by Jim 的 split-the-middle）
function pctRankAll(values){
  const n = values.length;
  return values.map(v => {
    let less=0, equal=0;
    for (const x of values){ if (x < v) less++; else if (x === v) equal++; }
    return 100 * (less + 0.5*equal) / n;
  });
}

// 以 log 價對時間做 OLS 斜率（動能 proxy）
function olsSlope(ys){
  const n = ys.length;
  if (n < 3) return NaN;
  // x = 1..n
  const sx = n*(n+1)/2;
  const sxx = n*(n+1)*(2*n+1)/6;
  let sy = 0, sxy = 0;
  for (let i=0;i<n;i++){
    const x = i+1;
    const y = ys[i];
    sy += y;
    sxy += x*y;
  }
  const num = n*sxy - sx*sy;
  const den = n*sxx - sx*sx;
  return den ? num/den : NaN;
}
// 動能：最近 LB=63 交易日的 log 價回歸斜率（年化可再乘比例，先不年化）
function momentum(series, lb=63){
  const seg = lastN(series.filter(Number.isFinite).map(x => Math.log(x)), lb);
  if (seg.length < Math.min(30, lb)) return NaN;
  return olsSlope(seg);
}

// 產出 sparkline：最近 90 天，min-max 到 0..100
function sparkline(series, span=90){
  const seg = lastN(series, span).filter(Number.isFinite);
  if (seg.length === 0) return [];
  const lo = Math.min(...seg), hi = Math.max(...seg);
  const rng = hi - lo || 1;
  return seg.map(v => Math.round(100*(v - lo)/rng));
}

// 主建構：給 rows（含 Date 與 20 檔欄位），回傳 analytics
function buildAnalytics(rows){
  const cols = getStockCols(rows);
  // 取全欄位序列
  const series = {};
  for (const c of cols){
    series[c] = rows.map(r => toNum(r[c]));
  }
  // 今天（最後一列）
  const last = rows[rows.length - 1] || {};
  // 為每檔算動能、robust z、百分位、標籤與 sparkline
  const mom = cols.map(c => momentum(series[c], 63));
  const { rz } = robustZAll(mom);
  const pcts = pctRankAll(mom);
  const label = pcts.map(p => p >= 66.6667 ? "S" : (p <= 33.3333 ? "W" : "N"));

  const board = cols.map((c,i) => ({
    code: c,
    price: toNum(last[c]),
    mom63: mom[i],
    rz: rz[i],
    pct: pcts[i],
    label: label[i],
    spark: sparkline(series[c], 90)  // 之後可直接餵給小圖
  }))
  // 依百分位由強到弱排序，方便檢視
  .sort((a,b) => b.pct - a.pct);

  return {
    asOf: last.Date,
    columns: cols,
    board,          // 今天的 S/N/W 看板
    series,         // 原始價序列（之後 UI 要用）
  };
}

// ---- 把它接到你現有的 main() 後面即可 ----
// 假設你原本在 main() 裡已經取得 rows（含 Date 與 20 檔）
const _orig_main = typeof main === "function" ? main : null;
async function main(){
  if (!_orig_main) return;
  await _orig_main(); // 先跑你原本的流程（含載圖）
  try{
    // 這裡假設你把 rows 掛在 window 上；若沒有，請把 rows 傳進來
    const rows = window.HK20?.rows || window.rows || null;
    if (!rows) return;
    const analytics = buildAnalytics(rows);
    window.HK20 = Object.assign({}, window.HK20, { analytics });
    console.log("[HK20] Analytics as of", analytics.asOf);
    console.table(analytics.board.map(x => ({
      code: x.code, label: x.label, pct: x.pct.toFixed(1),
      rz: x.rz.toFixed(2), mom63: (x.mom63 ?? NaN).toFixed(5)
    })));
  }catch(err){
    console.error("HK20 analytics error:", err);
  }
}
</script>
